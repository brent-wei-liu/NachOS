You will want a few new data structures in this part of the project. You will need a structure that represents a process' open files, a structure that represents the list of all a process' open files, a structure for an open file in a system, and a structure that represents all the open files in the system. Here is a brief explanation of each of these structure/classes:

A system's open file: Needs to contain information such as the filename, an OpenFile object, and the count of the number of processes that have this file open. The OpenFile object is what will be used to actually read and write to this file. You can look at this in filesys/openfile.h where the stubs are contained. The count will be used for determining if a file really needs to be closed or if we should leave it open because other processes are still using it. It will also determine if a file needs to be opened or if it is already open.
The system's open file list: This will contain the array of the system's open files and allow access to those objects. It will decide if a file already exists or if it really needs to be closed or not. You can use the bitmap (that you used in part one of the project) for managing the array of open files.
A process' open file: Needs to contain information such as the file name, the offset into this file for this particular process, and the index into the system wide file table. The offset is used for when you are reading or writing into the file. This is where you start reading from again if you do another read (or writing if you did a write). The index into the system's file table gives us access to the actual file of the system (that is synchronized from all different processes that access it). This mapping of a process' open file to the system file table allows each process to have it's own offset into the file (different from other processes) and makes it appear to the user that he actually has this file open all to himself (when really there is only one open copy of this file in the system's open file table).
The list of a processes open files: This will be an attribute of each PCB. It will have information such as an array of this process' open files which include the "always present" stdin and stdout. You can make the maximum number of open files for a process anything greater than 20. Once again, you can use the bitmap for this too.
Here is an overview of each of the calls and how they use the above processes:

Create: You will need to translate the file name passed in just as you did for the Exec system call. After doing this you can use fileSystem's Create function to create the file. This can be found in filesys/filesys.cc. You can create the file with an initial size of 0.
Open: You will need to translate the file name passed in just as you did in the Exec system call. Next you will want to add a new process open file to your list of your process' open files. This will in turn check to see if the system has this file open yet. If it does, the system file table increments the counter for that file. If it does not, the system will add a new system open file which will open the file using fileSystem's Open function. This can be found in filesys/filesys.cc.
Close: Using the file id passed in you will remove the open file from your process' list of open files and it in turn will let the system file table know to remove the file if necessary (ie. if the count > 0 then count--, otherwise remove file from list and close it). To close the file you can just clear out the reference in your system open file table to the open file. There is no actual close function that needs to be called. As far as the user is concerned you have closed the file.
Read: The main thing you need to do is translate the logical buffer address that the user passed in (what you are to read into) page by page and read into the translated address in memory each time you translate a page. To read each page you will call a read function in your structure for the list of your process' open files. This will get the correct open file, and handle the moving of the offset in the file. The system open file table is called from the process open file and asked to read. This is a synchronized read (since many process could be calling this system open file's read). You need to use locks and call OpenFile's ReadAt function. This is located in filesys/openfile.h). Remember to keep track of the actual number of bytes written (ReadAt returns this) and let the user know how many were actually read.
Write: You will also need to translate the logical buffer provided by the user argument page by page. You will write each page separately as you translate them. Just as Read does, Write will keep track of the offset in the process' open file and will ask the system open file table to write to the desired file. This will occur like Read except you will be calling OpenFile's WriteAt function.
Console Comments: To write to the console a user does not need to open or create any new files (this should be done in the constructor of the process' open file list). The user can simply call Read with "stdin" or write with "stdout" as the file name. Writing to stdout should just print to the terminal (use printf for this). Reading should just wait for the user to type something in and then press enter (use scanf to do this). Remember you cannot read from stdout and you cannot write to stdin.
Alterations to project 2 code: You will now need to close all your process' files when you exit. You will also need to add this file list to your pcb class for a process' open files.


